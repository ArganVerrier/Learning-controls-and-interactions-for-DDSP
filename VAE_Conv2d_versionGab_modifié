{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import os\n",
    "\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "from torchvision.datasets import FashionMNIST\n",
    "import torchvision.transforms as transforms\n",
    "from torch.utils.data import DataLoader\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "###### Espace latent 2 dimensions\n",
    "\n",
    "latent_dims = 8\n",
    "num_epochs = 20\n",
    "batch_size = 1\n",
    "capacity = 128\n",
    "learning_rate = 1e-4\n",
    "variational_beta = 0.001\n",
    "# use_gpu = True\n",
    "\n",
    "\n",
    "\n",
    "# # 10-d Espace latent en 10 dimensions, qui correspond à un Autoencoder simple (à comparer avec le VAE \n",
    "# et un espace latent de 2 dimensions)\n",
    "# latent_dims = 10\n",
    "# num_epochs = 100\n",
    "# batch_size = 128\n",
    "# capacity = 64\n",
    "# learning_rate = 1e-3\n",
    "# variational_beta = 1\n",
    "# use_gpu = True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Chargement des données \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(279, 2, 750)\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import descriptors\n",
    "import numpy as np\n",
    "\n",
    "dict_r = np.load('data_dict.npy', allow_pickle=True).item()\n",
    "\n",
    "train_db = np.zeros([len(dict_r['env']),2,750])\n",
    "\n",
    "\n",
    "i = 0\n",
    "for sample in dict_r['env']:\n",
    "    train_db[i,:,:] = sample\n",
    "    i+=1\n",
    "    \n",
    "MAX1 = np.max(train_db[:,0,:])\n",
    "MAX2 = np.max(train_db[:,1,:])\n",
    "train_db[:,0,:] /= MAX1\n",
    "train_db[:,1,:] /= MAX2\n",
    "train_dataset =  torch.utils.data.TensorDataset(torch.from_numpy(train_db))\n",
    "# train_db = train_db.reshape(-1,1,750*2)\n",
    "\n",
    "print(train_db.shape)\n",
    "train_loader = torch.utils.data.DataLoader(train_dataset, batch_size, shuffle=True)\n",
    "\n",
    "test_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size, shuffle=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Defintion du VAE \n",
    "\n",
    "Kernel Size = 4 papier qui explique pourquoi: https://distill.pub/2016/deconv-checkerboard/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of parameters: 9797905\n"
     ]
    }
   ],
   "source": [
    "class Encoder(nn.Module):\n",
    "    def __init__(self):\n",
    "        super(Encoder, self).__init__()\n",
    "        c = capacity\n",
    "#         self.conv1 = nn.Sequential(nn.Conv1d(in_channels=1, out_channels=c, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(c)) # out: c, 2, 750\n",
    "#         self.conv2 = nn.Sequential(nn.Conv1d(in_channels=c, out_channels=c*2, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(2*c)) # out: c*2, 2, 750\n",
    "        self.conv1 = nn.Conv1d(in_channels=1, out_channels=c, kernel_size=3, stride=1, padding=1) # out: c, 2, 750\n",
    "        self.conv2 = nn.Conv1d(in_channels=c, out_channels=c*2, kernel_size=3, stride=1, padding=1) # out: c*2, 2, 750\n",
    "        self.fc_mu = nn.Linear(in_features=2*c*2*750, out_features=latent_dims)\n",
    "        self.fc_logvar = nn.Linear(in_features=2*c*2*750, out_features=latent_dims)\n",
    "            \n",
    "    def forward(self, x):\n",
    "        x = F.relu(self.conv1(x))\n",
    "        x = F.relu(self.conv2(x))\n",
    "        x = x.view(x.size(0), -1) # flatten batch of multi-channel feature maps to a batch of feature vectors\n",
    "        x_mu = self.fc_mu(x)\n",
    "        x_logvar = self.fc_logvar(x)\n",
    "        return x_mu, x_logvar\n",
    "\n",
    "class Decoder(nn.Module):\n",
    "    def __init__(self):\n",
    "        super(Decoder, self).__init__()\n",
    "        c = capacity\n",
    "        self.fc = nn.Linear(in_features=latent_dims, out_features=2*c*2*750)\n",
    "#         self.conv2 = nn.Sequential(nn.ConvTranspose1d(in_channels=c*2, out_channels=c, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(c))\n",
    "#         self.conv1 = nn.Sequential(nn.ConvTranspose1d(in_channels=c, out_channels=1, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(1))\n",
    "        self.conv2 = nn.ConvTranspose1d(in_channels=c*2, out_channels=c, kernel_size=3, stride=1, padding=1)\n",
    "        self.conv1 = nn.ConvTranspose1d(in_channels=c, out_channels=1, kernel_size=3, stride=1, padding=1)\n",
    "            \n",
    "    def forward(self, x):\n",
    "        x = self.fc(x)\n",
    "        x = x.view(x.size(0), capacity*2, 2*750) # unflatten batch of feature vectors to a batch of multi-channel feature maps\n",
    "        x = F.relu(self.conv2(x))\n",
    "        x = torch.sigmoid(self.conv1(x)) # last layer before output is sigmoid, since we are using BCE as reconstruction loss\n",
    "        return x\n",
    "    \n",
    "class VariationalAutoencoder(nn.Module):\n",
    "    def __init__(self):\n",
    "        super(VariationalAutoencoder, self).__init__()\n",
    "        self.encoder = Encoder()\n",
    "        self.decoder = Decoder()\n",
    "    \n",
    "    def forward(self, x):\n",
    "        latent_mu, latent_logvar = self.encoder(x)\n",
    "        latent = self.latent_sample(latent_mu, latent_logvar)\n",
    "        x_recon = self.decoder(latent)\n",
    "        return x_recon, latent_mu, latent_logvar\n",
    "    \n",
    "    def latent_sample(self, mu, logvar):\n",
    "        if self.training:\n",
    "            # the reparameterization trick\n",
    "            std = logvar.mul(0.5).exp_()\n",
    "            eps = torch.empty_like(std).normal_()\n",
    "            return eps.mul(std).add_(mu)\n",
    "        else:\n",
    "            return mu\n",
    "    \n",
    "def vae_loss(recon_x, x, mu, logvar):\n",
    "    # recon_x is the probability of a multivariate Bernoulli distribution p.\n",
    "    # -log(p(x)) is then the pixel-wise binary cross-entropy.\n",
    "    # Averaging or not averaging the binary cross-entropy over all pixels here\n",
    "    # is a subtle detail with big effect on training, since it changes the weight\n",
    "    # we need to pick for the other loss term by several orders of magnitude.\n",
    "    # Not averaging is the direct implementation of the negative log likelihood,\n",
    "    # but averaging makes the weight of the other loss term independent of the image resolution.\n",
    "    recon_loss = F.mse_loss(recon_x.view(-1, batch_size*2*750), x.view(-1, batch_size*2*750), reduction='mean')\n",
    "    variational_beta = 0.001\n",
    "    # KL-divergence between the prior distribution over latent vectors\n",
    "    # (the one we are going to sample from when generating new images)\n",
    "    # and the distribution estimated by the generator for the given image.\n",
    "    kldivergence = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())\n",
    "    \n",
    "    return recon_loss + variational_beta * kldivergence, recon_loss, variational_beta * kldivergence\n",
    "    \n",
    "    \n",
    "vae = VariationalAutoencoder()\n",
    "\n",
    "# device = torch.device(\"cuda:0\")\n",
    "# vae = vae.to(device)\n",
    "\n",
    "num_params = sum(p.numel() for p in vae.parameters() if p.requires_grad)\n",
    "print('Number of parameters: %d' % num_params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Entrainement"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training ...\n",
      "Epoch [1 / 20] average reconstruction error: 0.043700 (l2 = 0.035095, l3 = 0.008605)\n",
      "Epoch [2 / 20] average reconstruction error: 0.017458 (l2 = 0.009746, l3 = 0.007712)\n",
      "Epoch [3 / 20] average reconstruction error: 0.015414 (l2 = 0.008505, l3 = 0.006909)\n",
      "Epoch [4 / 20] average reconstruction error: 0.012814 (l2 = 0.007158, l3 = 0.005656)\n",
      "Epoch [5 / 20] average reconstruction error: 0.011964 (l2 = 0.006811, l3 = 0.005153)\n",
      "Epoch [6 / 20] average reconstruction error: 0.010965 (l2 = 0.006017, l3 = 0.004948)\n",
      "Epoch [7 / 20] average reconstruction error: 0.010077 (l2 = 0.005650, l3 = 0.004426)\n",
      "Epoch [8 / 20] average reconstruction error: 0.009016 (l2 = 0.004956, l3 = 0.004060)\n",
      "Epoch [9 / 20] average reconstruction error: 0.008836 (l2 = 0.005068, l3 = 0.003768)\n",
      "Epoch [10 / 20] average reconstruction error: 0.008166 (l2 = 0.004639, l3 = 0.003528)\n",
      "Epoch [11 / 20] average reconstruction error: 0.007921 (l2 = 0.004674, l3 = 0.003247)\n",
      "Epoch [12 / 20] average reconstruction error: 0.007385 (l2 = 0.004170, l3 = 0.003215)\n",
      "Epoch [13 / 20] average reconstruction error: 0.007031 (l2 = 0.004017, l3 = 0.003013)\n",
      "Epoch [14 / 20] average reconstruction error: 0.006860 (l2 = 0.003907, l3 = 0.002954)\n",
      "Epoch [15 / 20] average reconstruction error: 0.006419 (l2 = 0.003653, l3 = 0.002766)\n",
      "Epoch [16 / 20] average reconstruction error: 0.006357 (l2 = 0.003576, l3 = 0.002781)\n",
      "Epoch [17 / 20] average reconstruction error: 0.005899 (l2 = 0.003353, l3 = 0.002546)\n",
      "Epoch [18 / 20] average reconstruction error: 0.005871 (l2 = 0.003342, l3 = 0.002528)\n",
      "Epoch [19 / 20] average reconstruction error: 0.006054 (l2 = 0.003373, l3 = 0.002681)\n",
      "Epoch [20 / 20] average reconstruction error: 0.005706 (l2 = 0.003103, l3 = 0.002603)\n"
     ]
    }
   ],
   "source": [
    "optimizer = torch.optim.Adam(params=vae.parameters(), lr=learning_rate, weight_decay=1e-5)\n",
    "\n",
    "# set to training mode\n",
    "vae.train()\n",
    "\n",
    "train_loss_avg = []\n",
    "train_loss_avg2 = []\n",
    "train_loss_avg3 = []\n",
    "\n",
    "print('Training ...')\n",
    "for epoch in range(num_epochs):\n",
    "    train_loss_avg.append(0)\n",
    "    train_loss_avg2.append(0)\n",
    "    train_loss_avg3.append(0)\n",
    "    num_batches = 0\n",
    "    \n",
    "    for image_batch in train_loader:\n",
    "\n",
    "        #image_batch = image_batch.to(device)\n",
    "        image_batch = torch.DoubleTensor(image_batch[0])\n",
    "        image_batch = image_batch.view(batch_size,1,2*750)\n",
    "        \n",
    "        # vae reconstruction\n",
    "        image_batch_recon, latent_mu, latent_logvar = vae(image_batch.float())\n",
    "        \n",
    "        # reconstruction error\n",
    "        loss, loss2, loss3 = vae_loss(image_batch_recon, image_batch.float(), latent_mu, latent_logvar)\n",
    "        \n",
    "        # backpropagation\n",
    "        optimizer.zero_grad()\n",
    "        loss.backward()\n",
    "        \n",
    "        \n",
    "        # one step of the optmizer (using the gradients from backpropagation)\n",
    "        optimizer.step()\n",
    "        \n",
    "        train_loss_avg[-1] += loss.item()\n",
    "        train_loss_avg2[-1] += loss2.item()\n",
    "        train_loss_avg3[-1] += loss3.item()\n",
    "        num_batches += 1\n",
    "        \n",
    "    train_loss_avg[-1] /= num_batches\n",
    "    train_loss_avg2[-1] /= num_batches\n",
    "    train_loss_avg3[-1] /= num_batches\n",
    "    print('Epoch [%d / %d] average reconstruction error: %f (l2 = %f, l3 = %f)' % (epoch+1, num_epochs, train_loss_avg[-1], train_loss_avg2[-1], train_loss_avg3[-1]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Affichage de la courbe de loss "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.ion()\n",
    "\n",
    "fig = plt.figure()\n",
    "plt.plot(train_loss_avg)\n",
    "plt.xlabel('Epochs')\n",
    "plt.ylabel('Loss')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Evaluation du score sur le Dataset de TEST"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "average reconstruction error: 0.010090\n"
     ]
    }
   ],
   "source": [
    "# set to evaluation mode\n",
    "vae.eval()\n",
    "\n",
    "test_loss_avg, num_batches = 0, 0\n",
    "for image_batch in test_dataloader:\n",
    "    \n",
    "    with torch.no_grad():\n",
    "    \n",
    "        #image_batch = image_batch.to(device)\n",
    "        image_batch = torch.DoubleTensor(image_batch[0])\n",
    "        Max_image_batch = torch.max(image_batch)\n",
    "        image_batch = image_batch.view(batch_size,1,2*750)/Max_image_batch\n",
    "        image_batch = image_batch.float()\n",
    "        # vae reconstruction\n",
    "        image_batch_recon, latent_mu, latent_logvar = vae(image_batch)\n",
    "\n",
    "        # reconstruction error\n",
    "        loss, loss2, loss3 = vae_loss(image_batch_recon, image_batch, latent_mu, latent_logvar)\n",
    "\n",
    "        test_loss_avg += loss.item()\n",
    "        num_batches += 1\n",
    "    \n",
    "test_loss_avg /= num_batches\n",
    "print('average reconstruction error: %f' % (test_loss_avg))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Reconstruction "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Image originale\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "VAE reconstruction:\n"
     ]
    },
    {
     "ename": "RuntimeError",
     "evalue": "Expected 3-dimensional input for 3-dimensional weight [128, 1, 3], but got 4-dimensional input of size [1, 1, 2, 750] instead",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-21-417942a7d836>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m     25\u001b[0m \u001b[1;31m# Reconstruct and visualise the images using the vae\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     26\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'VAE reconstruction:'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 27\u001b[1;33m \u001b[0mimages_recon\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mb\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mvae\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtorch\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mfrom_numpy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mimages\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mview\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mbatch_size\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m750\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mfloat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     28\u001b[0m \u001b[0mimages_recon\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mimages_recon\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdetach\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     29\u001b[0m \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mfigure\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\torch\\nn\\modules\\module.py\u001b[0m in \u001b[0;36m_call_impl\u001b[1;34m(self, *input, **kwargs)\u001b[0m\n\u001b[0;32m    720\u001b[0m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_slow_forward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    721\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 722\u001b[1;33m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mforward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    723\u001b[0m         for hook in itertools.chain(\n\u001b[0;32m    724\u001b[0m                 \u001b[0m_global_forward_hooks\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m<ipython-input-4-1b8daf55a6a5>\u001b[0m in \u001b[0;36mforward\u001b[1;34m(self, x)\u001b[0m\n\u001b[0;32m     42\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     43\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mforward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 44\u001b[1;33m         \u001b[0mlatent_mu\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlatent_logvar\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mencoder\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     45\u001b[0m         \u001b[0mlatent\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mlatent_sample\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mlatent_mu\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlatent_logvar\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     46\u001b[0m         \u001b[0mx_recon\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdecoder\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mlatent\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\torch\\nn\\modules\\module.py\u001b[0m in \u001b[0;36m_call_impl\u001b[1;34m(self, *input, **kwargs)\u001b[0m\n\u001b[0;32m    720\u001b[0m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_slow_forward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    721\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 722\u001b[1;33m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mforward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    723\u001b[0m         for hook in itertools.chain(\n\u001b[0;32m    724\u001b[0m                 \u001b[0m_global_forward_hooks\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m<ipython-input-4-1b8daf55a6a5>\u001b[0m in \u001b[0;36mforward\u001b[1;34m(self, x)\u001b[0m\n\u001b[0;32m     11\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     12\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mforward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 13\u001b[1;33m         \u001b[0mx\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mF\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrelu\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mconv1\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     14\u001b[0m         \u001b[0mx\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mF\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrelu\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mconv2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     15\u001b[0m         \u001b[0mx\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mview\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msize\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;31m# flatten batch of multi-channel feature maps to a batch of feature vectors\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\torch\\nn\\modules\\module.py\u001b[0m in \u001b[0;36m_call_impl\u001b[1;34m(self, *input, **kwargs)\u001b[0m\n\u001b[0;32m    720\u001b[0m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_slow_forward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    721\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 722\u001b[1;33m             \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mforward\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    723\u001b[0m         for hook in itertools.chain(\n\u001b[0;32m    724\u001b[0m                 \u001b[0m_global_forward_hooks\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\torch\\nn\\modules\\conv.py\u001b[0m in \u001b[0;36mforward\u001b[1;34m(self, input)\u001b[0m\n\u001b[0;32m    255\u001b[0m                             _single(0), self.dilation, self.groups)\n\u001b[0;32m    256\u001b[0m         return F.conv1d(input, self.weight, self.bias, self.stride,\n\u001b[1;32m--> 257\u001b[1;33m                         self.padding, self.dilation, self.groups)\n\u001b[0m\u001b[0;32m    258\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    259\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mRuntimeError\u001b[0m: Expected 3-dimensional input for 3-dimensional weight [128, 1, 3], but got 4-dimensional input of size [1, 1, 2, 750] instead"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "plt.ion()\n",
    "\n",
    "import torchvision.utils\n",
    "\n",
    "vae.eval()\n",
    "\n",
    "# En entrée, l'image à reconstruire et le modèle utilisé pour la reconstruction\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "images = train_db[55,:,:]\n",
    "# Affichage de l'image originale\n",
    "print('Image originale')\n",
    "\n",
    "plt.figure()\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot((images[0,:]))\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot((images[1,:]))        \n",
    "plt.show()\n",
    "\n",
    "# Reconstruct and visualise the images using the vae\n",
    "print('VAE reconstruction:')\n",
    "images_recon,a,b = vae(torch.from_numpy(images).view(batch_size,1,2,750).float())\n",
    "images_recon = images_recon.detach().numpy()\n",
    "plt.figure()\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot((images_recon[0,0,0,:]))\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot((images_recon[0,0,1,:]))   \n",
    "plt.show()\n",
    "\n",
    "\n",
    "images = train_db[8,:,:]\n",
    "# Affichage de l'image originale\n",
    "print('Image originale')\n",
    "\n",
    "plt.figure()\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot((images[0,:]))\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot((images[1,:]))        \n",
    "plt.show()\n",
    "\n",
    "# Reconstruct and visualise the images using the vae\n",
    "print('VAE reconstruction:')\n",
    "images_recon,a,b = vae(torch.from_numpy(images).view(batch_size,1,2,750).float())\n",
    "images_recon = images_recon.detach().numpy()\n",
    "plt.figure()\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot((images_recon[0,0,0,:]))\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot((images_recon[0,0,1,:])) \n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Sauvergarder valeurs de l'entrainement\n",
    "torch.save(model.state_dict(), 'Train_VAEconv_solordinario')\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "VariationalAutoencoder(\n",
       "  (encoder): Encoder(\n",
       "    (conv1): Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
       "    (conv2): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
       "    (fc_mu): Linear(in_features=192000, out_features=2, bias=True)\n",
       "    (fc_logvar): Linear(in_features=192000, out_features=2, bias=True)\n",
       "  )\n",
       "  (decoder): Decoder(\n",
       "    (fc): Linear(in_features=2, out_features=192000, bias=True)\n",
       "    (conv2): ConvTranspose2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
       "    (conv1): ConvTranspose2d(64, 1, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
       "  )\n",
       ")"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#charger les valeurs\n",
    "vae.load_state_dict(torch.load('Train_VAEconv_solordinario'))\n",
    "vae.eval()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
